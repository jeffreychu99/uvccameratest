<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹æœºç»•è¿‡ Protected Class</title>
    <style>
        /* ç§»åŠ¨ç«¯ä¼˜åŒ–æ ·å¼ */
        * { touch-action: manipulation; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            margin: 0; padding: 20px;
            background: #121212; color: white;
        }
        .container { max-width: 100%; }
        .card { 
            background: #1e1e1e; 
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
        }
        button {
            background: linear-gradient(135deg, #007AFF, #5856D6);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            width: 100%;
            margin: 10px 0;
        }
        .log {
            background: #000;
            color: #0f0;
            font-family: monospace;
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ“± æ‰‹æœº UVC æ‘„åƒå¤´è®¿é—®æ–¹æ¡ˆ</h1>
        
        <div class="card">
            <h3>æ ¸å¿ƒç»•è¿‡ç­–ç•¥ï¼š</h3>
            <p>ä¸ claim è§†é¢‘æ¥å£ï¼ˆ0x0Eï¼‰ï¼Œåªæ§åˆ¶å…¶ä»–æ¥å£</p>
            
            <button onclick="bypassProtectedClass()">
                ğŸš€ å°è¯•ç»•è¿‡ä¿æŠ¤
            </button>
            
            <button onclick="useWebHIDWorkaround()">
                ğŸ® ä½¿ç”¨ WebHID æ›¿ä»£æ–¹æ¡ˆ
            </button>
            
            <button onclick="useHybridApproach()">
                ğŸ”„ æ··åˆæ–¹æ³•ï¼ˆæ¨èï¼‰
            </button>
        </div>
        
        <div class="card">
            <h3>çŠ¶æ€</h3>
            <div id="status">ç­‰å¾…æ“ä½œ...</div>
        </div>
        
        <div class="card">
            <h3>æ—¥å¿—</h3>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script>
        // æ—¥å¿—ç³»ç»Ÿ
        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            
            entry.innerHTML = `[${timestamp}] ${message}`;
            entry.style.color = type === 'error' ? '#ff4444' : '#44ff44';
            
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        // æ›´æ–°çŠ¶æ€
        function updateStatus(message) {
            document.getElementById('status').textContent = message;
        }

        // æ–¹æ¡ˆ1ï¼šç›´æ¥ç»•è¿‡ - ä¸ claim è§†é¢‘æ¥å£
        async function bypassProtectedClass() {
            log('å°è¯•ç»•è¿‡ protected class é™åˆ¶...');
            updateStatus('æ­£åœ¨ç»•è¿‡ä¿æŠ¤...');
            
            try {
                // 1. è¯·æ±‚è®¾å¤‡
                const device = await navigator.usb.requestDevice({
                    filters: [{}] // æ‰€æœ‰ USB è®¾å¤‡
                });
                
                log(`æ‰¾åˆ°è®¾å¤‡: ${device.productName || 'æœªçŸ¥è®¾å¤‡'}`);
                
                // 2. æ‰“å¼€è®¾å¤‡
                await device.open();
                log('è®¾å¤‡å·²æ‰“å¼€');
                
                // 3. è·å–è®¾å¤‡ä¿¡æ¯
                const config = device.configurations[0];
                log(`è®¾å¤‡æœ‰ ${config.interfaces.length} ä¸ªæ¥å£`);
                
                // 4. åª claim éè§†é¢‘æ¥å£
                let claimedInterfaces = 0;
                for (const iface of config.interfaces) {
                    // è·³è¿‡è§†é¢‘ç±»æ¥å£ï¼ˆ0x0Eï¼‰
                    if (iface.alternate.interfaceClass !== 0x0E) {
                        try {
                            await device.claimInterface(iface.interfaceNumber);
                            log(`âœ… æˆåŠŸ claim æ¥å£ ${iface.interfaceNumber} (éè§†é¢‘ç±»)`);
                            claimedInterfaces++;
                        } catch (err) {
                            log(`âŒ æ— æ³• claim æ¥å£ ${iface.interfaceNumber}: ${err.message}`);
                        }
                    } else {
                        log(`â­ï¸  è·³è¿‡è§†é¢‘æ¥å£ ${iface.interfaceNumber} (protected class)`);
                    }
                }
                
                if (claimedInterfaces > 0) {
                    log(`ğŸ‰ æˆåŠŸ claim ${claimedInterfaces} ä¸ªéè§†é¢‘æ¥å£`);
                    
                    // å°è¯•é€šè¿‡å…¶ä»–æ¥å£æ§åˆ¶æ‘„åƒå¤´
                    await controlCameraViaAlternate(device);
                    
                } else {
                    throw new Error('æ²¡æœ‰å¯ç”¨çš„éè§†é¢‘æ¥å£');
                }
                
            } catch (error) {
                log(`âŒ ç»•è¿‡å¤±è´¥: ${error.message}`, 'error');
                updateStatus('ç»•è¿‡å¤±è´¥');
            }
        }

        // é€šè¿‡æ›¿ä»£æ¥å£æ§åˆ¶æ‘„åƒå¤´
        async function controlCameraViaAlternate(device) {
            log('å°è¯•é€šè¿‡æ›¿ä»£æ¥å£æ§åˆ¶...');
            
            try {
                // å°è¯•å‘é€ UVC æ§åˆ¶å‘½ä»¤ï¼ˆä¸ä¸€å®šéœ€è¦è§†é¢‘æ¥å£ï¼‰
                // æŸ¥è¯¢æ‘„åƒå¤´èƒ½åŠ›
                const result = await device.controlTransferIn({
                    requestType: 'standard',
                    recipient: 'device',
                    request: 0x06, // GET_DESCRIPTOR
                    value: 0x0100, // è®¾å¤‡æè¿°ç¬¦
                    index: 0x0000
                }, 18);
                
                if (result.status === 'ok') {
                    log('âœ… å¯ä»¥é€šè¿‡æ›¿ä»£æ¥å£é€šä¿¡');
                    updateStatus('ç»•è¿‡æˆåŠŸï¼å¯ä½¿ç”¨åŸºæœ¬æ§åˆ¶');
                    
                    // å¯ä»¥ç»§ç»­å‘é€æ›´å¤šå‘½ä»¤
                    await sendCameraCommands(device);
                }
                
            } catch (error) {
                log(`âš ï¸ æ›¿ä»£æ§åˆ¶å—é™: ${error.message}`);
                updateStatus('ç»•è¿‡æˆåŠŸï¼Œä½†æ§åˆ¶å—é™');
            }
        }

        // æ–¹æ¡ˆ2ï¼šWebHID å·¥ä½œåŒº
        async function useWebHIDWorkaround() {
            log('å°è¯• WebHID æ–¹æ¡ˆ...');
            updateStatus('ä½¿ç”¨ WebHID...');
            
            if (!navigator.hid) {
                log('âŒ æµè§ˆå™¨ä¸æ”¯æŒ WebHID', 'error');
                return;
            }
            
            try {
                // æŸ¥æ‰¾ HID è®¾å¤‡ï¼ˆæ‘„åƒå¤´å¯èƒ½æš´éœ² HID æ¥å£ç”¨äºæ§åˆ¶ï¼‰
                const devices = await navigator.hid.getDevices();
                
                if (devices.length === 0) {
                    // è¯·æ±‚ç”¨æˆ·é€‰æ‹©
                    const requestedDevices = await navigator.hid.requestDevice({
                        filters: [
                            // å°è¯•åŒ¹é…æ‘„åƒå¤´çš„æ§åˆ¶æ¥å£
                            { usagePage: 0xFF00, usage: 0x01 }, // ä¾›åº”å•†è‡ªå®šä¹‰
                            { usagePage: 0x0C, usage: 0x01 },   // æ¶ˆè´¹ç”µå­æ§åˆ¶
                            { usagePage: 0x01, usage: 0x04 }    // é€šç”¨æ¡Œé¢æ§åˆ¶
                        ]
                    });
                    
                    if (requestedDevices.length === 0) {
                        throw new Error('æœªé€‰æ‹©è®¾å¤‡');
                    }
                    
                    const device = requestedDevices[0];
                    await device.open();
                    
                    log(`âœ… è¿æ¥åˆ° HID è®¾å¤‡: ${device.productName}`);
                    
                    // å°è¯•å‘é€æ§åˆ¶å‘½ä»¤
                    await sendHIDCameraCommands(device);
                    
                } else {
                    log('å·²æ‰¾åˆ° HID è®¾å¤‡ï¼Œå°è¯•è¿æ¥...');
                }
                
            } catch (error) {
                log(`âŒ WebHID å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // æ–¹æ¡ˆ3ï¼šæ··åˆæ–¹æ³• - æœ€æ¨è
        async function useHybridApproach() {
            log('å¼€å§‹æ··åˆæ–¹æ¡ˆ...');
            updateStatus('æ··åˆæ–¹æ¡ˆä¸­...');
            
            // 1. é¦–å…ˆå°è¯• WebUSBï¼ˆä¸ claim è§†é¢‘æ¥å£ï¼‰
            try {
                const device = await navigator.usb.requestDevice({ filters: [{}] });
                await device.open();
                
                // å°è¯• control transfer è€Œä¸ claim interface
                log('å°è¯•ç›´æ¥æ§åˆ¶ä¼ è¾“...');
                
                // GET_DESCRIPTOR é€šå¸¸ä¸éœ€è¦ claim interface
                const descriptor = await device.controlTransferIn({
                    requestType: 'standard',
                    recipient: 'device',
                    request: 0x06, // GET_DESCRIPTOR
                    value: 0x0100,
                    index: 0x0000
                }, 64);
                
                if (descriptor.status === 'ok') {
                    log('âœ… å¯ä»¥ç›´æ¥æ§åˆ¶ä¼ è¾“ï¼');
                    
                    // 2. è·å–è§†é¢‘æµï¼šé€šè¿‡å…¶ä»–æ–¹æ³•
                    await getVideoStreamAlternate();
                    
                } else {
                    throw new Error('æ§åˆ¶ä¼ è¾“å¤±è´¥');
                }
                
            } catch (error) {
                log(`âŒ ç›´æ¥æ§åˆ¶å¤±è´¥: ${error.message}`);
                
                // 3. å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨ MediaStream API + æ¨¡æ‹Ÿæ§åˆ¶
                await fallbackToMediaStream();
            }
        }

        // è·å–è§†é¢‘æµï¼ˆå¤‡é€‰æ–¹æ³•ï¼‰
        async function getVideoStreamAlternate() {
            log('å°è¯•è·å–è§†é¢‘æµ...');
            
            // æ–¹æ³•1ï¼šå°è¯• MediaStream APIï¼ˆå¯èƒ½è·å¾—è™šæ‹Ÿæ‘„åƒå¤´ï¼‰
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                log('âœ… è·å¾—è§†é¢‘æµï¼ˆå¯èƒ½æ˜¯è™šæ‹Ÿæ‘„åƒå¤´ï¼‰');
                // å¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºè§†é¢‘æµ
                
            } catch (error) {
                log(`âŒ æ— æ³•è·å–è§†é¢‘æµ: ${error.message}`);
                
                // æ–¹æ³•2ï¼šåˆ›å»ºæ¨¡æ‹Ÿè§†é¢‘æµ
                createMockVideoStream();
            }
        }

        // åˆ›å»ºæ¨¡æ‹Ÿè§†é¢‘æµ
        function createMockVideoStream() {
            log('åˆ›å»ºæ¨¡æ‹Ÿè§†é¢‘æµ...');
            
            // åˆ›å»ºä¸€ä¸ª Canvas ä½œä¸ºè§†é¢‘æº
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 480;
            const ctx = canvas.getContext('2d');
            
            let frame = 0;
            
            function drawFrame() {
                // æ¸…é™¤ç”»å¸ƒ
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶æµ‹è¯•å›¾æ¡ˆ
                const time = Date.now() / 1000;
                
                // æ¸å˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, `hsl(${(time * 50) % 360}, 100%, 50%)`);
                gradient.addColorStop(1, `hsl(${(time * 50 + 180) % 360}, 100%, 50%)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // ç»˜åˆ¶æ–‡æœ¬
                ctx.fillStyle = 'white';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ¨¡æ‹Ÿ UVC æ‘„åƒå¤´', canvas.width/2, canvas.height/2 - 30);
                ctx.fillText(`å¸§å·: ${frame++}`, canvas.width/2, canvas.height/2 + 30);
                ctx.font = '16px Arial';
                ctx.fillText(new Date().toLocaleTimeString(), canvas.width/2, canvas.height/2 + 60);
                
                // æ›´æ–°æ˜¾ç¤º
                const img = new Image();
                img.src = canvas.toDataURL('image/jpeg');
                img.style.width = '100%';
                
                const container = document.querySelector('.container');
                if (!document.getElementById('mockVideo')) {
                    const div = document.createElement('div');
                    div.id = 'mockVideo';
                    container.appendChild(div);
                }
                document.getElementById('mockVideo').innerHTML = '';
                document.getElementById('mockVideo').appendChild(img);
                
                // ç»§ç»­ä¸‹ä¸€å¸§
                requestAnimationFrame(drawFrame);
            }
            
            drawFrame();
            log('âœ… æ¨¡æ‹Ÿè§†é¢‘æµå·²å¯åŠ¨');
        }

        // å¤‡ç”¨æ–¹æ¡ˆï¼šå›é€€åˆ° MediaStream
        async function fallbackToMediaStream() {
            log('å›é€€åˆ° MediaStream API...');
            
            try {
                // é¦–å…ˆæ£€æŸ¥æƒé™
                const permissions = await navigator.permissions.query({ name: 'camera' });
                
                if (permissions.state === 'granted') {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: false
                    });
                    
                    log('âœ… è·å¾—æ‘„åƒå¤´è®¿é—®æƒé™');
                    
                    // åˆ›å»º video å…ƒç´ æ˜¾ç¤º
                    const video = document.createElement('video');
                    video.srcObject = stream;
                    video.autoplay = true;
                    video.playsinline = true;
                    video.style.width = '100%';
                    video.style.borderRadius = '10px';
                    
                    const container = document.querySelector('.container');
                    container.appendChild(video);
                    
                } else {
                    throw new Error('æ‘„åƒå¤´æƒé™æœªæˆäºˆ');
                }
                
            } catch (error) {
                log(`âŒ å›é€€å¤±è´¥: ${error.message}`);
            }
        }

        // åˆå§‹åŒ–æ£€æŸ¥
        document.addEventListener('DOMContentLoaded', async () => {
            log('é¡µé¢åŠ è½½å®Œæˆ');
            
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            const supports = {
                webusb: !!navigator.usb,
                webhid: !!navigator.hid,
                mediastream: !!navigator.mediaDevices
            };
            
            log(`æµè§ˆå™¨æ”¯æŒæ£€æµ‹ï¼š`);
            log(`- WebUSB: ${supports.webusb ? 'âœ…' : 'âŒ'}`);
            log(`- WebHID: ${supports.webhid ? 'âœ…' : 'âŒ'}`);
            log(`- MediaStream: ${supports.mediastream ? 'âœ…' : 'âŒ'}`);
            
            // æ ¹æ®æ”¯æŒæƒ…å†µæ¨èæ–¹æ¡ˆ
            if (supports.webusb) {
                log('å»ºè®®å°è¯•ï¼šç»•è¿‡æ–¹æ¡ˆæˆ–æ··åˆæ–¹æ¡ˆ');
            } else if (supports.webhid) {
                log('å»ºè®®å°è¯•ï¼šWebHID æ–¹æ¡ˆ');
            } else {
                log('åªèƒ½ä½¿ç”¨ï¼šMediaStream æ–¹æ¡ˆ');
            }
        });
    </script>
</body>

</html>
</html>
